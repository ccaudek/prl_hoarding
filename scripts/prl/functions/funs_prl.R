# Script name: funs_prl.R
# Project: Hoarding Project, AUSL Bologna 
# Script purpose: functions to be used
# @author: Ilaria Colpizzi
# Date Created: Gen 5 10:48 2023
# Last Modified Date: Gen 5 10:48 2023
# 
# Notes: 


# gen_RDS_files_with_prl_raw_data() ---------------------------------------

# One RDS file for patiens and one for controls. The files contain all 
# raw PRL data, with the psychtoolkit code for each subject. The output is:
# here("data", "processed", "prl", STIMULUS, "patients_with_psychtoolkit_code.rds")
# here("data", "processed", "prl", STIMULUS, "controls_with_psychtoolkit_code.rds")

#' @description 
#' Generate four RDS files (group: 2 x condition: 2) with raw PRL data of each
#' participant.
#' @input
#' Raw data generated by psychtoolkit. 
#' @return 
#' NULL. 
#' @export
load_psychtoolkit_files <- function() {
  
  generate_rds_for_prl(GROUP = "patients", STIMULUS = "hoarding", TYPE = "book")
  generate_rds_for_prl(GROUP = "patients", STIMULUS = "hoarding", TYPE = "dress_female")
  generate_rds_for_prl(GROUP = "patients", STIMULUS = "hoarding", TYPE = "dress_male")
  generate_rds_for_prl(GROUP = "patients", STIMULUS = "neutral", TYPE = "object")
  generate_rds_for_prl(GROUP = "patients", STIMULUS = "neutral", TYPE = "shape")
  generate_rds_for_prl(GROUP = "controls", STIMULUS = "hoarding", TYPE = "book")
  generate_rds_for_prl(GROUP = "controls", STIMULUS = "hoarding", TYPE = "dress_female")
  generate_rds_for_prl(GROUP = "controls", STIMULUS = "hoarding", TYPE = "dress_male")
  generate_rds_for_prl(GROUP = "controls", STIMULUS = "neutral", TYPE = "shape")
}

# generate_rds_for_prl() --------------------------------------------------

#' @description 
#' generate RDS file for PRL data
#' @return NULL.
#' @param 
#' GROUP: patient, control
#' STIMULUS: food, social
generate_rds_for_prl <- function(GROUP, STIMULUS, TYPE) {
  
  dir <- here("data", "raw", "_prl", GROUP, STIMULUS, TYPE)
  
  file_names <- as.character(list.files(path=dir, pattern = "PRL"))
  n_files <- length(file_names)
  n_files
  
  d_list <- list()
  
  for (i in 1:n_files) {
    
    d  <- read.table(here("data", "raw", "_prl", GROUP, STIMULUS, TYPE, file_names[i]))
    
    d$subj_idx <- file_names[i]
    d$epoch <- d$V1
    d$target_position <- d$V2
    d$stimulus_type <- d$V3
    d$stimulus_class <- d$V4
    d$which_image_is_rewarded_more <- d$V5
    d$image_category <- d$V6
    d$keypress <- d$V7 # (1=a, 2=l)
    d$rt <- d$V8
    d$feedback <- d$V9 # 1 = reward, 2 = punishment, 3 = too slow
    d$V10 <- NULL
    # on each trial, a food picture and a neutral image
    # the food/social image is coded as image2
    d$is_target_img_rewarded_in_first_epoch <- ifelse(
      d$V5 == "image1_rewarded7", "no", "yes"
    )
    
    d$epoch <- as.numeric(stri_sub(d$V1, 5, 5))
    # d$V1 <- NULL
    
    d$is_target_rewared_in_present_epoch <- rep(c(0, 1, 0, 1), each = 40)
    
    # V2: position of target image (sad face)
    # where is the target img?
    
    d$position_target_img <-  if (STIMULUS == "hoarding") {
      stri_sub(d$V2, 8, 9)
      } else { stri_sub(d$V2, 9, 10)}
    
    # V7 key pressed by participant
    # 1 : "a" -> sx
    # 2 : "l" -> dx
    
    # participant has chosen the image to the right or to the left
    d$resp <- ifelse(
      d$V7 == 1, "sx",
      ifelse(d$V7 == 2, "dx", "ERROR")
    )
    
    d$is_target_img_chosen <- ifelse(
      d$resp == d$position_target_img, 1, 0
    )
    
    d$is_positive_feedback <- case_when(
      d$V9 == 1 ~ "yes",
      d$V9 == 2 ~ "no",
      d$V9 == 3 ~ "no response"
    )
    
    d$trial <- 1:160

    d_list[[i]] <- d
  }
  
  # convert list into data.frame
  df <- do.call(rbind.data.frame, d_list)
  
  if (GROUP == "controls") {
    saveRDS(df, here("data", "processed", "_prl", STIMULUS, TYPE, "controls_with_psychtoolkit_code.rds"))
  } else {
    saveRDS(df, here("data", "processed", "_prl", STIMULUS, TYPE, "patients_with_psychtoolkit_code.rds"))
  }
}

# gen_data_list_with_prl_raw_data() ---------------------------------------

# Generate data list and add subj_name
# Reads the four RDS files with the raw PRL data, adds subj_name used in the
# questionnaires. The four data.frame are added to a list.

#' @description 
#' Read the raw data and add subj_name.
#' @input NULL
#' @return data_list list with 4 DataFrames:

write_prl_raw_data_list <- function() {
  
  df_book_patients <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "patients", 
    TYPE = "book"
  )
  
  df_dressf_patients <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "patients", 
    TYPE = "dress_female"
  )
  
  df_dressm_patients <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "patients", 
    TYPE = "dress_male"
  )
  
  df_shape_neutral_patients <- add_quest_code_to_data(
    STIMULUS = "neutral", 
    GROUP = "patients", 
    TYPE = "shape"
  )
  
  df_object_neutral_patients <- add_quest_code_to_data(
    STIMULUS = "neutral", 
    GROUP = "patients", 
    TYPE = "object"
  )
  
  df_book_controls <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "controls", 
    TYPE = "book"
  )
  
  df_dressf_controls <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "controls", 
    TYPE = "dress_female"
  )
  
  df_dressm_controls <- add_quest_code_to_data(
    STIMULUS = "hoarding", 
    GROUP = "controls", 
    TYPE = "dress_male"
  )
  
  df_shape_neutral_controls <- add_quest_code_to_data(
    STIMULUS = "neutral", 
    GROUP = "controls", 
    TYPE = "shape"
  )
  
  data_list <- list()
  
  data_list[[1]] <- df_book_patients
  data_list[[2]] <- df_dressf_patients
  data_list[[3]] <- df_dressm_patients
  data_list[[4]] <- df_shape_neutral_patients
  data_list[[5]] <- df_object_neutral_patients
  data_list[[6]] <- df_book_controls
  data_list[[7]] <- df_dressf_controls
  data_list[[8]] <- df_dressm_controls
  data_list[[9]] <- df_shape_neutral_controls
  
  data_list
}



# add_quest_code_to_data() ------------------------------------------------


#' @description 
#' Generate a data.frame with the raw PRL data and the subj_name codes.
#' As input are used the psytoolkit codes.
#' @return 
#' Data.frame.
add_quest_code_to_data <- function(STIMULUS, GROUP, TYPE) {
  
  correspondence_table_for_subj_codes <- 
    gen_correspondence_table_codes(GROUP, STIMULUS, TYPE)
  
  if (GROUP == "patients") {
    data_psytoolkit_code <- readRDS(
      here("data", "processed", "_prl", 
           STIMULUS, TYPE, "patients_with_psychtoolkit_code.rds")
    ) %>% 
      dplyr::rename("code_psytoolkit" = "subj_idx")
  } else {
    data_psytoolkit_code <- readRDS(
      here("data", "processed", "_prl", 
           STIMULUS, TYPE, "controls_with_psychtoolkit_code.rds")
    ) %>% 
      dplyr::rename("code_psytoolkit" = "subj_idx")
  }
  
  df <- inner_join(
    correspondence_table_for_subj_codes, data_psytoolkit_code, 
    by = "code_psytoolkit"
  )
  df
}



# gen_correspondence_table_codes() ----------------------------------------


#' @description 
#' by using the information in the Excel file, generates a correspondence table
#' which associates the codes used by psytoolkit with the codes used in the
#' questionnaires
#' @return data.frame.
gen_correspondence_table_codes <- function(GROUP, STIMULUS, TYPE) {
  
  d <- read_excel_code(GROUP, STIMULUS, TYPE)
  d <- gen_subj_name(d)
  d$stimulus <- STIMULUS
  
  d_clean <- d %>% 
    dplyr::rename("subj_name" = "subj_id") %>% 
    dplyr::select(subj_name, code_psytoolkit, stimulus)
  
  d_clean2 <- d_clean[!is.na(d_clean$code_psytoolkit), ] 
  # d_food_clean2$code_psytoolkit
  d_clean2
}


# read_excel_code() -------------------------------------------------------


#' @description 
#' read Excel file.
#' @return data.frame.
#' @param 
#' GROUP = "patients", EXCEL_FILE = "misc_food".
read_excel_code <- function(GROUP, STIMULUS, TYPE) {
  d_hoarding <- readxl::read_excel(
    here("data", "raw", "_prl", GROUP, STIMULUS, TYPE, "data.xlsx")
  )
  d_hoarding
}


# gen_subj_name() ---------------------------------------------------------


#' @description 
#' generate subject code
#' @return data.frame.
#' @param data.frame.
gen_subj_name <- function(d) {
  
  library("stringi")
  
  d$mese_c <- ifelse(
    d$`mese:1` < 10, stri_join("0", as.character(d$`mese:1`), sep=''), as.character(d$`mese:1`)
  )
  
  d$giorno_c <- ifelse(
    d$`giorno:1` < 10, 
    stri_join("0", as.character(d$`giorno:1`), sep=''), 
    as.character(d$`giorno:1`)
  )
  
  d$cellulare_c <- ifelse(
    d$`cellulare:1` < 100, 
    stri_join("0", as.character(d$`cellulare:1`), sep=''), 
    as.character(d$`cellulare:1`)
  )
  
  d$sex <- ifelse(d$`sesso:1` == 1, "f",
                  ifelse(d$`sesso:1` == 2, "m", NA))
  
  d$subj_id <- tolower(
    stri_join(d$`nome:1`, d$`cognome:1`, d$`anno:1`, 
              d$mese_c, d$giorno_c, d$cellulare_c, d$sex, 
              sep='_')
  )
  
  d$code_psytoolkit <- d$`esperimento:1`
  
  d
}



# correct_subj_name() -----------------------------------------------------


# Correct string subj_name
# The typos in subj_name are corrected. The input is the data list produced
# by gen_data_list_with_prl_raw_data(). The output is a data list.

#' @description 
#' Pass each element of data_list to correct_subj_name_in_one_df(),
#' where subj_name is corrected.
#' @return data_list list with 4 DataFrames.
correct_subj_names <- function(data_list) {
  
  df1 <- correct_subj_name_in_one_df(data_list, "patients", "hoarding", "book")
  df2 <- correct_subj_name_in_one_df(data_list, "patients", "hoarding", "dress_female")
  df3 <- correct_subj_name_in_one_df(data_list, "patients", "hoarding", "dress_male")
  df4 <- correct_subj_name_in_one_df(data_list, "patients", "neutral", "shape")
  df5 <- correct_subj_name_in_one_df(data_list, "patients", "neutral", "object")
  df6 <- correct_subj_name_in_one_df(data_list, "controls", "hoarding", "book")
  df7 <- correct_subj_name_in_one_df(data_list, "controls", "hoarding", "dress_female")
  df8 <- correct_subj_name_in_one_df(data_list, "controls", "hoarding", "dress_male")
  df9 <- correct_subj_name_in_one_df(data_list, "controls", "neutral", "shape")

  data_list <- list()
  data_list[[1]] <- df1
  data_list[[2]] <- df2
  data_list[[3]] <- df3
  data_list[[4]] <- df4
  data_list[[5]] <- df5
  data_list[[6]] <- df6
  data_list[[7]] <- df7
  data_list[[8]] <- df8
  data_list[[9]] <- df9
  
  data_list
}


# correct_subj_name_in_one_df() -------------------------------------------


#' @description 
#' Function used by correct_subj_name(). For each of the four elements of the 
#' data list, subj_name is corrected.
#' @return 
#' Data-frame.
correct_subj_name_in_one_df <- function(data_list, GROUP, STIMULUS, TYPE) {
  
  if (GROUP == "patients" & STIMULUS == "hoarding" & TYPE == "book") {
    d <- data_list[[1]] 
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "patients"
  } else if (GROUP == "patients" & STIMULUS == "hoarding" & TYPE == "dress_female") {
    d <- data_list[[2]]
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "patients"
  } else if (GROUP == "patients" & STIMULUS == "hoarding" & TYPE == "dress_male") {
    d <- data_list[[3]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "patients"
  } else if (GROUP == "patients" & STIMULUS == "neutral" & TYPE == "shape") {
    d <- data_list[[4]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "patients"
  } else if (GROUP == "patients" & STIMULUS == "neutral" & TYPE == "object") {
    d <- data_list[[5]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "patients"
  } else if (GROUP == "controls" & STIMULUS == "hoarding" & TYPE == "book") {
    d <- data_list[[6]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "controls"
  } else if (GROUP == "controls" & STIMULUS == "hoarding" & TYPE == "dress_female") {
    d <- data_list[[7]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "controls"
  } else if (GROUP == "controls" & STIMULUS == "hoarding" & TYPE == "dress_male") {
    d <- data_list[[8]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "controls"
  } else if (GROUP == "controls" & STIMULUS == "neutral" & TYPE == "shape") {
    d <- data_list[[9]] # df_social_patients
    d$subj_name <- factor(d$subj_name)
    d$subj_name <- d$subj_name %>% 
      forcats::fct_recode(
      )
    d$group <- "controls"
  } else {
    warning('ERROR in data_list')
  }
  d
}

# remove_subjects_with_too_many_nas() -------------------------------------


# Remove PRL sessions with too many NAs
# In some PRL sessions, participants only completed a fraction of the trials.
# When this fraction is too large, the whole session is removed.

#' @description 
#' Remove PRL sessions with too many NAs.
#' @input 
#' Data list.
#' @return NULL. 
#' @save Save file here("data", "processed", "prl", "complete_cleaned_raw_data", 
#' "clean_raw_data_prl.rds")
binding_cleaned_data_frames <- function(d_list) {
  
  d <- bind_rows(d_list[[1]], d_list[[2]], d_list[[3]], d_list[[4]], 
                 d_list[[5]], d_list[[6]], d_list[[7]], d_list[[8]], 
                 d_list[[9]])
  saveRDS(
    d, 
    here("data", "processed", "_prl", "complete_cleaned_raw_data", 
         "raw_data_prl_both_groups.rds")
  )
  
}


# find_subj_code_low_rich_choices() ---------------------------------------


# Find control subjects with rich choices <= 0.5.

#' @description 
#' Only for controls: find subj_code with proportion of rich choices < 0.5.
#' @input 
#' Address of data frame.
#' @return vector of subj_code.
#' find_subj_code_low_rich_choices <- function(file_address) {
#'   
#'   d <- readRDS(file_address)
#'   
#'   d$feedback <- ifelse(
#'     d$feedback == 2, 0, d$feedback
#'   )
#'   d$feedback <- ifelse(d$feedback == 3, NA, d$feedback)
#'   
#'   d$rich_choice <- case_when(
#'     d$is_target_rewared_in_present_epoch & d$is_target_img_chosen ~ 1,
#'     !d$is_target_rewared_in_present_epoch & !d$is_target_img_chosen ~ 1,
#'     TRUE ~ 0
#'   )
#'   
#'   foo <- d %>% 
#'     group_by(group, subj_name) %>% 
#'     summarise(
#'       avg_rich_choices = mean(rich_choice, na.rm = TRUE),
#'       avg_feedback = mean(feedback, na.rm = TRUE),
#'       n = n()
#'     ) 
#'   
#'   boxplot(foo$avg_feedback ~ foo$group)
#'   
#'   temp <- foo[foo$group == "controls" & foo$avg_feedback < 0.5, ]
#'   length(temp$subj_name)
#'   
#' 
#'   bad_ids_accuracy <- foo[
#'     foo$avg_rich_choices <= 0.5 & foo$group == "controls", 
#'   ]$subj_name
#'   
#'   bad_ids_accuracy
#'   
#' }
#' 
#' 
#' # find_subj_code_extreme_keypress() ---------------------------------------
#' 
#' 
#' # Find subjects with extreme keypress distributions.
#' # Each stimulus (e.g., food image) was presented to the left in the 
#' # 50% of cases, and on the right the other 50%. Pressing too often one key 
#' # means that the participant does not perform the task. Flagged subjects are 
#' # outside the interval [0.2, 0.8].
#' 
#' #' @description 
#' #' Find subject codes for control participants who pressed too often one of   
#' #' the two keys. 
#' #' @input 
#' #' Address of data frame.
#' #' @return 
#' #' Vector with subj_name codes.
#' find_subj_code_extreme_keypress <- function (d) {
#'   
#'   foo <- d %>% 
#'     group_by(group, stimulus_type, subj_name) %>% 
#'     summarise(
#'       y = mean(keypress-1, na.rm = TRUE)
#'     ) 
#'   
#'   foo1 <- foo[(foo$y < 0.3 | foo$y > 0.7) & foo$group == "controls", ]
#'   foo1 %>% 
#'     as.data.frame()
#'   
#'   bad_ids_controls_keypress <- factor(unique(foo1$subj_name))
#'   length(bad_ids_controls_keypress)
#'   
#'   bad_ids_controls_keypress
#' }


# add_diagnostic_category() ----------------------------------------------------

# add_diagnostic_category <- function() {
#   
#   # Read patients list and diagnostic category.
#   patients_from_excel_list <- 
#     rio::import(
#       here::here(
#         "data", "raw", "misc", "diagn_cat.xlsx"
#       )
#     ) 
#   
#   tbl_patients <- tibble(
#     subj_name = patients_from_excel_list$subj_code,
#     diag_cat = patients_from_excel_list$category
#   )
#   
#   # Read complete raw PRL data.
#   prl_raw_data <- readRDS(
#     here("data", "processed", "_prl", "complete_cleaned_raw_data", 
#          "raw_data_prl_both_groups.rds")
#   )
#   
#   prl_raw_data_and_diag_cat <- 
#     left_join(prl_raw_data, tbl_patients, by = "subj_name")
#   # table(prl_raw_data_and_diag_cat$diag_cat, prl_raw_data_and_diag_cat$group)
#   
#   prl_raw_data_and_diag_cat$diag_cat <- ifelse(
#     is.na(prl_raw_data_and_diag_cat$diag_cat), "HC", 
#     prl_raw_data_and_diag_cat$diag_cat
#   )
#   # summary(factor(prl_raw_data_and_diag_cat$diag_cat))
#   
#   # Read questionaires data
#   quest_data <- readRDS(
#     here::here("data", "processed", "quest", "quest_diagn_data.rds")
#   )
#   
#   quest_info <- quest_data %>%
#     dplyr::select(subj_code, eat26_tot) %>% 
#     distinct() %>% 
#     dplyr::rename(
#       subj_name = subj_code
#     )
#   
#   prl_tot_raw_data <- left_join(prl_raw_data_and_diag_cat, quest_info, by = "subj_name")
#   
#   prl_tot_raw_data$diag_cat <- ifelse(
#     ((prl_tot_raw_data$diag_cat == "HC") & (prl_tot_raw_data$eat26_tot > 19)), 
#     "RI", prl_tot_raw_data$diag_cat
#   )
#   
#   saveRDS(
#     prl_tot_raw_data,
#     here::here("data", "processed", "prl", "raw_prl_data", "prl_tot_raw_data.rds")
#   )
# }


# write_input1_for_hddmrl() -----------------------------------------------

write_input_for_hddmrl <- function() {
  
  prl_data <- readRDS(
    here::here("data", "processed", "_prl", "complete_cleaned_raw_data", "raw_data_prl_both_groups.rds")
  )
  
  prl_data %>% 
    group_by(group, stimulus) %>% 
    summarise(
      n = n_distinct(subj_name)
    )
  
  prl_data$feedback <- ifelse(
    prl_data$feedback == 2, 0, prl_data$feedback
  )
  prl_data$feedback <- ifelse(prl_data$feedback == 3, NA, prl_data$feedback)
  
  prl_data$feedback <- 
    ifelse(prl_data$rt < 150 | prl_data$rt > 2499, NA, prl_data$feedback)
  
  prl_data$rt1 <- 
    ifelse(prl_data$rt < 150 | prl_data$rt > 2499, NA, prl_data$rt)
  
  prl_data$rt1 <- ifelse(prl_data$trial == 1, NA, prl_data$rt1)
  
  prl_data %>% 
    summarise(
      n = n_distinct(subj_name)
    )
  
  data_for_imp <- prl_data %>% 
    dplyr::select(
      subj_name, stimulus, epoch, target_position, which_image_is_rewarded_more,
      keypress, rt1, feedback, is_target_img_rewarded_in_first_epoch, 
      is_target_rewared_in_present_epoch, position_target_img, resp, 
      is_target_img_chosen, trial, group
    )
  
  set.seed(123)
  miceObj <- miceRanger::miceRanger(
    data_for_imp
    , m = 1
    , returnModels = TRUE
    , verbose = TRUE
  )
  
  dataList <- miceRanger::completeData(miceObj)
  
  d <- dataList[[1]]
  
  accuracy_df <- d %>% 
    dplyr::filter(group == "controls") %>% 
    group_by(subj_name) %>% 
    summarise(
      avg_acc = mean(feedback, na.rm = TRUE),
      avg_rt = median(rt1, na.rm = TRUE)
    ) %>% 
    arrange(avg_acc, desc(avg_rt))
  
  accuracy_df %>% as.data.frame()
  
  ids_bad_cntr_acc_rt <- 
    accuracy_df[(accuracy_df$avg_acc < 0.45 | accuracy_df$avg_rt < 300), ]$subj_name
  
  prl_data2 <- d[!(d$subj_name %in% ids_bad_cntr_acc_rt), ]
  
  # Subjects flagged with careless responding with accuracy < 0.55
  bad_ids_careless <- c(
    "en_li_1967_08_12_088_f", "al_fo_1998_12_05_663_f", "ri_ga_1973_04_22_878_f",
    "el_pa_1963_06_21_872_f"
  )
  
  prl_data3 <- prl_data2[!(prl_data2$subj_name %in% bad_ids_careless), ]
  
  prl_data3 %>% 
    # group_by(group, diag_cat) %>% 
    summarise(
      n = n_distinct(subj_name)
    )
  
  prl_data3$is_rich_choice <- case_when(
    prl_data3$is_target_rewared_in_present_epoch & prl_data3$is_target_img_chosen ~ 1,
    !prl_data3$is_target_rewared_in_present_epoch & !prl_data3$is_target_img_chosen ~ 1,
    TRUE ~ 0
  )
  
  # response: which image has been chosen in each trial
  prl_data3$response <- prl_data3$is_target_img_chosen
  
  # d$is_patient <- ifelse(d$group == "patients", 1, 0)
  
  prl_data3$rt <- prl_data3$rt1 / 1000
  prl_data3$rt1 <- NULL
  
  # I want to number each subject in the data.frame so that subjects are 
  # ordered sequentially, according to the order they appear in the data frame. 
  # https://community.rstudio.com/t/why-does-group-indices-use-alphabetical-ordering/5452
  # As suggested in the above link, I wrap group_indices in another function:
  grpid = function(x) match(x, unique(x))
  # then
  d1 <- prl_data3 %>% 
    mutate(subj_idx = group_indices(., subj_name) %>% grpid)
  # In this manner, the variable subj_idx assigns an integer to each subject;
  # this integer is ordered according to the sequence in which the subjects are 
  # present in the data.frame.
  # table(d3$subj_idx)
  # unique(d3$subj_idx)
  
  d1$stimulus <- factor(d1$stimulus)
  d1$diag_cat <- d1$group %>%
    forcats::fct_recode(
      HC = "controls", 
      DDA = "patients" # DDA -- disturbo da accumulo
    )
  
  d1 <- d1 %>% 
    dplyr::rename(
      stim = stimulus
    )
  
  d1$split_by <- ifelse(d1$stim == "hoarding", 0, 1)
  
  # d1$key_press <- ifelse(d1$resp == "sx", 0, 1)
  # sdb <- function(x) {
  #   sqrt((1/length(x)) *  mean(x) * (1 - mean(x)))
  # }
  # 
  # out <- d1 %>% 
  #   group_by(subj_name, stimulus) %>% 
  #   summarise(
  #     intra_sd = sdb(key_press)
  #   )
  # 
  # ggplot(out, aes(intra_sd, fill = stimulus)) + 
  #   geom_density(alpha = 0.2) +
  #   xlim(0.0375, 0.04)
  # out[out$intra_sd < 0.0385, ]$subj_name
  
  
  df_for_hddm <- data.frame(
    subj_idx   = d1$subj_idx,
    response   = d1$response,
    stim       = d1$stim,
    rt         = d1$rt,
    trial      = d1$trial,
    split_by   = d1$split_by,
    feedback   = d1$feedback,
    diag_cat   = d1$diag_cat,
    subj_code  = d1$subj_name,
    q_init     = 0.5
  )
  
  mydat <- df_for_hddm %>% 
    dplyr::arrange(subj_idx, trial, split_by)
  
  mydat %>% 
    group_by(diag_cat) %>% 
    summarise(
      n = n_distinct(subj_code)
    )
  # diag_cat     n
  # 1 AN          38
  # 2 AN_R        10
  # 3 BN          12
  # 4 BN_R         5
  # 5 HC         219
  # 6 RI          25
  
  mydat %>% 
    summarise(
      n = n_distinct(subj_code)
    )
  
  rio::export(
    mydat, 
    here("data", "processed", "_prl", "input_for_hddmrl", "hddm_input_20230105.csv")
  )
  
  lut <- tibble(
    subj_idx = mydat$subj_idx, 
    subj_code = mydat$subj_code
  ) %>% 
    distinct()
  
  rio::export(
    lut, 
    here("data", "processed", "_prl", "input_for_hddmrl", "hddm_look_up_table_20230105.csv")
  )
  
}



# write_input_for_hddmrl() -----------------------------------------------

# This version removes all participants with Gelman-Rubin convergence 
# problems. The excluded participants all belong to the HC group, apart from 
# "al_ro_1989_04_25_160_f", who is AN.

# write_input_for_hddmrl <- function() {
#   
#   prl_data <- readRDS(
#     here::here("data", "processed", "prl", "raw_prl_data", "prl_tot_raw_data.rds")
#   )
#   
#   prl_data$feedback <- ifelse(
#     prl_data$feedback == 2, 0, prl_data$feedback
#   )
#   prl_data$feedback <- ifelse(prl_data$feedback == 3, NA, prl_data$feedback)
#   
#   prl_data$feedback <- 
#     ifelse(prl_data$rt < 150 | prl_data$rt > 2499, NA, prl_data$feedback)
#   
#   prl_data$rt1 <- 
#     ifelse(prl_data$rt < 150 | prl_data$rt > 2499, NA, prl_data$rt)
#   
#   prl_data$rt1 <- ifelse(prl_data$trial == 1, NA, prl_data$rt1)
#   
#   # For 37 control participants we don't have the questionnaires. 
#   # They are all attributed to the HC category.
#   prl_data$diag_cat <- ifelse(is.na(prl_data$diag_cat), "HC", prl_data$diag_cat)
#   
#   data_for_imp <- prl_data %>% 
#     dplyr::select(
#       subj_name, stimulus_type, epoch, target_position, which_image_is_rewarded_more,
#       keypress, rt1, feedback, is_target_img_rewarded_in_first_epoch, 
#       is_target_rewared_in_present_epoch, position_target_img, resp, 
#       is_target_img_chosen, trial, group, diag_cat
#     )
#   
#   set.seed(123)
#   miceObj <- miceRanger::miceRanger(
#     data_for_imp
#     , m = 1
#     , returnModels = TRUE
#     , verbose = TRUE
#   )
#   
#   dataList <- miceRanger::completeData(miceObj)
#   
#   d <- dataList[[1]]
#   
#   accuracy_df <- d %>% 
#     dplyr::filter(group == "controls") %>% 
#     group_by(subj_name) %>% 
#     summarise(
#       avg_acc = mean(feedback, na.rm = TRUE),
#       avg_rt = median(rt1, na.rm = TRUE)
#     ) %>% 
#     arrange(avg_rt)
#   
#   accuracy_df %>% as.data.frame()
#   
#   ids_bad_cntr_acc_rt <- 
#     accuracy_df[(accuracy_df$avg_acc < 0.45 | accuracy_df$avg_rt < 300), ]$subj_name
#   
#   prl_data2 <- d[!(d$subj_name %in% ids_bad_cntr_acc_rt), ]
#   
#   # Read list of subj_name for participants flagged for careless responding on
#   # the questionnaires data.
#   careless_resp_ids <- readRDS(
#     here::here(
#       "scripts", "R", "scripts_quest", "02_flag_careless_resp", 
#       "bad_ids_from_careless_resp_indices.rds"
#     )
#   )
#   
#   # Both the ids found with the traditional careless responding methods and the
#   # ids used with the method_1 procedure.
#   bad_ids_method1 <- c(
#     "gi_ma_2001_05_02_922_f", "an_si_1996_01_03_744_m", "to_pi_2000_09_11_140_m",
#     "bi_sa_2001_03_01_675_f", "ch_ma_1995_08_28_639_f", "vi_mi_2000_08_21_472_f",
#     "an_ma_1995_01_07_728_f", "il_si_1995_11_28_393_f", "ma_lu_2000_09_18_459_m",
#     "ca_ma_2001_07_01_650_f", "sa_pa_2001_05_14_311_f", "lo_pi_2001_09_08_203_m",
#     "ag_no_2000_02_12_330_f", "cr_la_1997_12_18_107_f")
#   
#   bad_ids_careless <- c(
#     careless_resp_ids, bad_ids_method1
#   )
#   
#   controls_with_low_accuracy <- accuracy_df[accuracy_df$avg_acc < 0.5, ]$subj_name
#   
#   to_be_excluded <- bad_ids_careless[bad_ids_careless %in% controls_with_low_accuracy]
#   
#   # These subjects are removed because of convergence problems with hDDMrl.
#   to_be_excluded2 <- c(
#     "ja_qu_1999_09_21_439_m", 
#     "ma_ma_2000_03_26_404_f", "da_sc_1993_01_08_813_f", "ir_po_1993_02_15_077_f",
#     "an_am_1993_05_20_789_f", "si_co_1992_03_23_596_f",
#     "so_tr_2001_01_04_222_f", "so_ca_1996_09_12_448_f",
#     "al_ro_1989_04_25_160_f", # AN
#     to_be_excluded)
#   
#   # to_be_excluded <- accuracy_df[
#   #   accuracy_df$subj_name %in% bad_ids_careless & accuracy_df$avg_acc < 0.5, 
#   # ]$subj_name
#   
#   prl_data3 <- prl_data2[!(prl_data2$subj_name %in% to_be_excluded2), ]
#   
#   prl_data3 %>% 
#     group_by(group, diag_cat) %>% 
#     summarise(
#       n = n_distinct(subj_name)
#     )
#   
#   prl_data3 %>% 
#     summarise(
#       n = n_distinct(subj_name)
#     )
#   
#   prl_data3$is_rich_choice <- case_when(
#     prl_data3$is_target_rewared_in_present_epoch & prl_data3$is_target_img_chosen ~ 1,
#     !prl_data3$is_target_rewared_in_present_epoch & !prl_data3$is_target_img_chosen ~ 1,
#     TRUE ~ 0
#   )
#   
#   # response: which image has been chosen in each trial
#   prl_data3$response <- prl_data3$is_target_img_chosen
#   
#   prl_data3$rt <- prl_data3$rt1 / 1000
#   prl_data3$rt1 <- NULL
#   
#   # I want to number each subject in the data.frame so that subjects are 
#   # ordered sequentially, according to the order they appear in the data frame. 
#   # https://community.rstudio.com/t/why-does-group-indices-use-alphabetical-ordering/5452
#   # As suggested in the above link, I wrap group_indices in another function:
#   grpid = function(x) match(x, unique(x))
#   # then
#   d1 <- prl_data3 %>% 
#     mutate(subj_idx = group_indices(., subj_name) %>% grpid)
#   # In this manner, the variable subj_idx assigns an integer to each subject;
#   # this integer is ordered according to the sequence in which the subjects are 
#   # present in the data.frame.
#   # table(d3$subj_idx)
#   # unique(d3$subj_idx)
#   
#   d1$stimulus_type <- factor(d1$stimulus_type)
#   d1$stimulus_type <- d1$stimulus_type %>% 
#     forcats::fct_recode(
#       neutral = "socialshame"
#     )
#   
#   d1 <- d1 %>% 
#     dplyr::rename(
#       stim = stimulus_type
#     )
#   
#   d1$split_by <- ifelse(d1$stim == "food", 0, 1)
#   
#   df_for_hddm <- data.frame(
#     subj_idx   = d1$subj_idx,
#     response   = d1$response,
#     stim       = d1$stim,
#     rt         = d1$rt,
#     trial      = d1$trial,
#     split_by   = d1$split_by,
#     feedback   = d1$feedback,
#     diag_cat   = d1$diag_cat,
#     subj_code  = d1$subj_name,
#     q_init     = 0.5
#   )
#   
#   mydat <- df_for_hddm %>% 
#     dplyr::arrange(subj_idx, trial, split_by)
#   
#   mydat %>% 
#     summarise(
#       n = n_distinct(subj_code)
#     )
#   
#   rio::export(
#     mydat, 
#     here("data", "processed", "prl", "input_for_hddmrl", "hddm_input_v3.csv")
#   )
#   
#   lut <- data.frame(
#     subj_idx = mydat$subj_idx, 
#     subj_code = mydat$subj_code
#   ) %>% 
#     distinct()
#   
#   rio::export(
#     lut, 
#     here("data", "processed", "prl", "input_for_hddmrl", "hddm_look_up_table_v3.csv")
#   )
#   
# }





# find_patients_codes() ---------------------------------------------------

#' 
#' #' @description 
#' #' Find patients subj_codes.
#' #' @input 
#' #' NULL.
#' #' @return 
#' #' Vector of subj_code.
#' find_patients_codes <- function() {
#'   require("purrr")
#'   
#'   # Get individual parameters of the Rescorla-Wagner model
#'   d <- rio::import(
#'     here(
#'       "data", "processed", "prl", "data_for_rescorla_wagner", 
#'       "params_individual_rescorla_wagner.csv"
#'     )
#'   ) %>% 
#'     dplyr::rename(
#'       subj_code = subj_name
#'     )
#'   
#'   only_patients <- d %>% 
#'     dplyr::filter(is_patient == 1)
#'   
#'   only_patients <- only_patients %>% 
#'     mutate(subj_code = fct_recode(subj_code, "Not_specified" = ""))
#'   
#'   unique(only_patients$subj_code) %>% 
#'     purrr::discard(is.na)
#' }


#---- EOF ----#


























#' 
#' #' @description 
#' #' Flag at-risk (EAT-26) controls
#' #' @return NULL. Save file "tot_raw_data_prl.rds".
#' flag_at_risk_eat26_controls <- function() {
#'   
#'   at_risk_subj_names <- get_subj_name_at_risk_eat26() %>% 
#'     factor()
#'   patients_codes <- get_patients_codes()
#'   
#'   at_risk_controls_codes <- setdiff(at_risk_subj_names, patients_codes)
#'   
#' }
#' 
#' 
#' 
#' 
#' #' @description 
#' #' Get subj_name of at-risk subjects from questionnaires data.
#' #' @return Vector of subj_names.
#' get_subj_name_at_risk_eat26 <- function() {
#'   
#'   # Read questionnaire data
#'   quest_df <- readRDS(here("data", "processed", "quest", "quest_data.rds"))
#'   
#'   
#'   subjects_at_risk <- quest_df %>% 
#'     dplyr::filter(at_risk == 1)
#'   
#'   # these are both controls and patients
#'   subj_name_at_risk <- subjects_at_risk$subj_code
#'   
#'   subj_name_at_risk
#' }






